package jmt

import (
	"bytes"
	"fmt"
	"slices"
)

func bitLength(d Digest) int {
	return len(d) * 8
}

func bitGet(d Digest, index int) bool {
	return (d[index/8] & (1 << (7 - index%8))) != 0
}

func commonPrefixLengthInBits(a Digest, b Digest) int {
	lastMatchIndex := -1
	for i := 0; i < bitLength(a) && i < bitLength(b); i++ {
		if bitGet(a, i) == bitGet(b, i) {
			lastMatchIndex = i
		} else {
			break
		}
	}
	return lastMatchIndex + 1
}

type indexedSparseMerkleNode struct {
	index            Digest
	sparseMerkleNode sparseMerkleNode
}

type BoundingLeaf struct {
	Leaf     LeafKeyAndValueDigests
	Siblings []Digest
}

const MaxBoundingLeaves = 2

// VerifySubrange verifies that the key-value pairs in keyValues are the only
// ones included in the key digest subrange [startIndex, endInclIndex], in the
// tree rooted at expectedRootDigest.
func VerifySubrange(
	expectedRootDigest Digest,
	startIndex Digest,
	endInclIndex Digest,
	keyValues []KeyValue,
	boundingLeaves []BoundingLeaf,
) error {
	if !(bytes.Compare(startIndex[:], endInclIndex[:]) <= 0) {
		return fmt.Errorf("start index %x is not less than or equal to the end incl index %x", startIndex, endInclIndex)
	}

	sortedDigestedKeyValues := make([]digestedKeyValue, 0, len(keyValues))
	for _, kv := range keyValues {
		sortedDigestedKeyValues = append(sortedDigestedKeyValues, digestedKeyValue{
			kv.Key,
			DigestKey(kv.Key),
			kv.Value,
			DigestValue(kv.Value),
		})
	}
	slices.SortFunc(sortedDigestedKeyValues, func(a, b digestedKeyValue) int {
		return bytes.Compare(a.keyDigest[:], b.keyDigest[:])
	})
	for i := range sortedDigestedKeyValues {
		if i > 0 && !(bytes.Compare(sortedDigestedKeyValues[i-1].keyDigest[:], sortedDigestedKeyValues[i].keyDigest[:]) < 0) {
			return fmt.Errorf("key values contain duplicates")
		}
	}

	if len(sortedDigestedKeyValues) > 0 {
		// Ensure key digests are within bounds of the subrange.
		if !(bytes.Compare(startIndex[:], sortedDigestedKeyValues[0].keyDigest[:]) <= 0) {
			return fmt.Errorf("start index %x is not less than or equal to the min key digest %x", startIndex, sortedDigestedKeyValues[0].keyDigest)
		}
		if !(bytes.Compare(sortedDigestedKeyValues[len(sortedDigestedKeyValues)-1].keyDigest[:], endInclIndex[:]) <= 0) {
			return fmt.Errorf("end incl index %x is not greater than or equal to the max key digest %x", endInclIndex, sortedDigestedKeyValues[len(sortedDigestedKeyValues)-1].keyDigest)
		}
	}

	// This layer is generated by the key-value pairs we received, padded with
	// the bounding leaves on the left and right.
	bottommostLayer := make([]indexedSparseMerkleNode, 0, len(sortedDigestedKeyValues)+2)

	var (
		leftBoundingLeafOrNil  *BoundingLeaf
		rightBoundingLeafOrNil *BoundingLeaf
	)

	switch len(boundingLeaves) {
	case 0:
	case 1:
		if bytes.Compare(boundingLeaves[0].Leaf.KeyDigest[:], startIndex[:]) <= 0 {
			leftBoundingLeafOrNil = &boundingLeaves[0]
		} else if bytes.Compare(endInclIndex[:], boundingLeaves[0].Leaf.KeyDigest[:]) <= 0 {
			rightBoundingLeafOrNil = &boundingLeaves[0]
		} else {
			return fmt.Errorf("bounding leaf key digest %x is not less than or equal to the start index %x or greater than or equal to the end incl index %x", boundingLeaves[0].Leaf.KeyDigest, startIndex, endInclIndex)
		}
	case 2:
		leftBoundingLeafOrNil = &boundingLeaves[0]
		rightBoundingLeafOrNil = &boundingLeaves[1]
	default:
		return fmt.Errorf("unexpected number of bounding leaves: %v", len(boundingLeaves))
	}

	if leftBoundingLeafOrNil != nil {
		leftBoundingIndex := leftBoundingLeafOrNil.Leaf.KeyDigest
		leftBoundingCmpStart := bytes.Compare(leftBoundingIndex[:], startIndex[:])
		switch leftBoundingCmpStart {
		case -1:
			// Left bounding leaf is completely to the left of the range, we can safely add it to the bottommost layer
			bottommostLayer = append(bottommostLayer, indexedSparseMerkleNode{
				leftBoundingIndex,
				sparseMerkleNode{
					true,
					digestLeafBinary(leftBoundingIndex, leftBoundingLeafOrNil.Leaf.ValueDigest),
				},
			})
		case 0:
			// If the left bounding leaf is in range but not included in keyvalues, error out
			if len(sortedDigestedKeyValues) == 0 {
				return fmt.Errorf("left bounding leaf key digest %x is in range but not included in keyvalues", leftBoundingLeafOrNil.Leaf.KeyDigest)
			}
			if sortedDigestedKeyValues[0].keyDigest != leftBoundingIndex {
				return fmt.Errorf("left bounding leaf key digest %x is in range but not in keyvalues: bounding key digest %v, keyvalues first key digest %v", leftBoundingLeafOrNil.Leaf.KeyDigest, leftBoundingLeafOrNil.Leaf.KeyDigest, sortedDigestedKeyValues[0].keyDigest)
			}
			if sortedDigestedKeyValues[0].valueDigest != leftBoundingLeafOrNil.Leaf.ValueDigest {
				return fmt.Errorf("left bounding leaf key digest %x is in range but improperly included in keyvalues: bounding value digest %v, keyvalues value digest %v", leftBoundingLeafOrNil.Leaf.KeyDigest, leftBoundingLeafOrNil.Leaf.ValueDigest, sortedDigestedKeyValues[0].valueDigest)
			}
		case 1:
			return fmt.Errorf("left bounding leaf key digest %x is greater than the start index %x", leftBoundingLeafOrNil.Leaf.KeyDigest, startIndex)
		}
	}

	for _, kv := range sortedDigestedKeyValues {
		leafDigest := digestLeafBinary(kv.keyDigest, kv.valueDigest)
		bottommostLayer = append(bottommostLayer, indexedSparseMerkleNode{
			kv.keyDigest,
			sparseMerkleNode{
				true,
				leafDigest,
			},
		})
	}

	if rightBoundingLeafOrNil != nil {
		rightBoundingIndex := rightBoundingLeafOrNil.Leaf.KeyDigest
		rightBoundingCmpEndIncl := bytes.Compare(rightBoundingIndex[:], endInclIndex[:])
		switch rightBoundingCmpEndIncl {
		case 1:
			// Right bounding leaf comes after end of range, we can safely add it to the bottommost layer
			bottommostLayer = append(bottommostLayer, indexedSparseMerkleNode{
				rightBoundingIndex,
				sparseMerkleNode{
					true,
					digestLeafBinary(rightBoundingIndex, rightBoundingLeafOrNil.Leaf.ValueDigest),
				},
			})
		case 0:
			// If the right bounding leaf is in range but not included in keyvalues, error out
			if len(sortedDigestedKeyValues) == 0 {
				return fmt.Errorf("right bounding leaf key digest %x is in range but not included in keyvalues", rightBoundingLeafOrNil.Leaf.KeyDigest)
			}
			if sortedDigestedKeyValues[len(sortedDigestedKeyValues)-1].keyDigest != rightBoundingIndex {
				return fmt.Errorf("right bounding leaf key digest %x is in range but not in keyvalues: bounding key digest %v, keyvalues last key digest %v", rightBoundingLeafOrNil.Leaf.KeyDigest, rightBoundingLeafOrNil.Leaf.KeyDigest, sortedDigestedKeyValues[len(sortedDigestedKeyValues)-1].keyDigest)
			}
			if sortedDigestedKeyValues[len(sortedDigestedKeyValues)-1].valueDigest != rightBoundingLeafOrNil.Leaf.ValueDigest {
				return fmt.Errorf("right bounding leaf key digest %x is in range but improperly included in keyvalues: bounding value digest %v, keyvalues value digest %v", rightBoundingLeafOrNil.Leaf.KeyDigest, rightBoundingLeafOrNil.Leaf.ValueDigest, sortedDigestedKeyValues[len(sortedDigestedKeyValues)-1].valueDigest)
			}
		case -1:
			// Right bounding leaf comes before end of range
			return fmt.Errorf("right bounding leaf key digest %x is less than the end incl index %x", rightBoundingLeafOrNil.Leaf.KeyDigest, endInclIndex)
		}
	}

	if len(bottommostLayer) == 0 {
		// Prover is claiming the tree is empty, and we know there are no
		// bounding leaves or siblings of them otherwise the bottommost layer
		// would not be empty. So we can safely add a placeholder node and have
		// it bubble to the top.
		bottommostLayer = append(bottommostLayer, indexedSparseMerkleNode{
			startIndex,
			sparseMerkleNode{
				false,
				SparseMerklePlaceholderDigest,
			},
		})
	}

	return verifySubrangePadded(
		expectedRootDigest,
		bottommostLayer,
		leftBoundingLeafOrNil,
		rightBoundingLeafOrNil,
	)
}

func siblingDigests(
	left Digest,
	right Digest,
	depth int,
) bool {
	return commonPrefixLengthInBits(left, right) == depth && !bitGet(left, depth) && bitGet(right, depth)
}

func cumulativeOccurrencesOfBit(d Digest, b bool) []int {
	acc := make([]int, bitLength(d))
	for i := 0; i < bitLength(d); i++ {
		if i > 0 {
			acc[i] = acc[i-1]
		}
		if bitGet(d, i) == b {
			acc[i]++
		}
	}
	return acc
}

func verifySubrangePadded(
	expectedRootDigest Digest,
	bottommostLayer []indexedSparseMerkleNode,
	leftBoundingLeafOrNil *BoundingLeaf,
	rightBoundingLeafOrNil *BoundingLeaf,
) error {
	expectedLeftSiblingsAtDepth := make([]int, bitLength(Digest{}))
	expectedRightSiblingsAtDepth := make([]int, bitLength(Digest{}))
	if leftBoundingLeafOrNil != nil {
		expectedLeftSiblingsAtDepth = cumulativeOccurrencesOfBit(leftBoundingLeafOrNil.Leaf.KeyDigest, true)
	}
	if rightBoundingLeafOrNil != nil {
		expectedRightSiblingsAtDepth = cumulativeOccurrencesOfBit(rightBoundingLeafOrNil.Leaf.KeyDigest, false)
	}

	layer := bottommostLayer
	maxDepth := bitLength(Digest{}) - 1
	for depth := maxDepth; depth >= 0; depth-- {
		parentLayer := make([]indexedSparseMerkleNode, 0, len(layer)/2)

		for i := 0; i < len(layer); i++ {
			index := layer[i].index
			node := layer[i].sparseMerkleNode
			bit := bitGet(index, depth)

			var parentNode sparseMerkleNode
			switch bit {
			case false:
				// We are looking for a right sibling...

				var rightSibling sparseMerkleNode

				// Is this the rightmost node in layer?
				if i+1 == len(layer) {
					if rightBoundingLeafOrNil != nil && len(rightBoundingLeafOrNil.Siblings) > 0 && expectedRightSiblingsAtDepth[depth] == len(rightBoundingLeafOrNil.Siblings) {
						// Either our right siblings cover this level.
						rightSibling = sparseMerkleNode{false, rightBoundingLeafOrNil.Siblings[0]}
						rightBoundingLeafOrNil.Siblings = rightBoundingLeafOrNil.Siblings[1:]
					} else {
						// Or we put a placeholder node.
						rightSibling = sparseMerkleNode{false, SparseMerklePlaceholderDigest}
					}
				} else if siblingDigests(index, layer[i+1].index, depth) {
					// The immediately next node in layer is a right sibling!
					rightSibling = layer[i+1].sparseMerkleNode
					i++ // Skip over the right sibling we just used.
				} else {
					// We put a placeholder node.
					rightSibling = sparseMerkleNode{false, SparseMerklePlaceholderDigest}
				}

				parentNode = sparseDigestInternalBinary(node, rightSibling)
			case true:
				// We are looking for a left sibling...

				var leftSibling sparseMerkleNode

				// Is this the leftmost node in layer?
				if i == 0 {
					if leftBoundingLeafOrNil != nil && len(leftBoundingLeafOrNil.Siblings) > 0 && expectedLeftSiblingsAtDepth[depth] == len(leftBoundingLeafOrNil.Siblings) {
						// Either our left siblings cover this level.
						leftSibling = sparseMerkleNode{false, leftBoundingLeafOrNil.Siblings[0]}
						leftBoundingLeafOrNil.Siblings = leftBoundingLeafOrNil.Siblings[1:]
					} else {
						// Or we put a placeholder node.
						leftSibling = sparseMerkleNode{false, SparseMerklePlaceholderDigest}
					}
				} else {
					// If there was a left sibling in layer we'd already have
					// processed this node as its right sibling, and skipped
					// over it. Thus there's no appropriate left sibling in
					// layer.
					leftSibling = sparseMerkleNode{false, SparseMerklePlaceholderDigest}
				}

				parentNode = sparseDigestInternalBinary(leftSibling, node)
			}

			parentLayer = append(parentLayer, indexedSparseMerkleNode{
				// We are being lazy and not truncating the index to the depth
				// of the parent node.
				index,
				parentNode,
			})
		}
		layer = parentLayer
	}

	if len(layer) != 1 {
		return fmt.Errorf("unexpectedly ended with a non-singleton layer of %v nodes at the top", len(layer))
	}
	if !((leftBoundingLeafOrNil == nil || len(leftBoundingLeafOrNil.Siblings) == 0) && (rightBoundingLeafOrNil == nil || len(rightBoundingLeafOrNil.Siblings) == 0)) {
		return fmt.Errorf("unexpectedly ended with left or right siblings remaining: left %v, right %v", len(leftBoundingLeafOrNil.Siblings), len(rightBoundingLeafOrNil.Siblings))
	}
	if layer[0].sparseMerkleNode.digest != expectedRootDigest {
		return fmt.Errorf("computed root digest mismatch: computed %x, expected %x", layer[0].sparseMerkleNode.digest, expectedRootDigest)
	}
	return nil
}
